#!/usr/bin/env bash
PREFIX="${PREFIX:-/usr}"
in=0

set -f # disable globbing
IFS=':'
#shellcheck disable=2206
confs=( $XDG_CONFIG_DIRS $XDG_CONFIG_HOME "$HOME/.config" "$HOME/.local/lib" \
	"/etc" "$PREFIX/local/lib" "$PREFIX/lib" )
IFS=
set +f # re-enable globbing

help(){
	cat >&2 << EOF
Usage: $0 [ -i ] [ -o str ] [ -e str ] [ -O str ] [ -h | -H ]  command [ args ... ]

	-u       Force using unbuffer if installed
	-U       Don't use unbuffer
	-i       colorize from stdin instead of command (combine with one of -[oeO]
	-o str   colorize stdout using the given file or spec
	-e str   colorize stderr using the given file or spec
	-O str   colorize both stdour and stderr the given file or spec
	-h       show this help and exit
	-H       show more help and exit
EOF
	(( ${#1} )) || return
	cat >&2 << EOF

By default, $0 will colorize the command's stdout with \`\`command.1.*'',
and the command's stderr with \`\`command.2.*''. If a spec is specified (with -[oeO]),
then \`\`spec.*'' will be searched for instead. If a spec contains a \`/', then it is
considered to be a file.

The paths $0 will look for with your current environment are:
EOF
	for p in "${confs[@]}"; do
		printf >&2 '\t%s/acolor\n' "$p"
	done
}

while getopts 'ie:o:O:uUhH' o; do
	case "$o" in
		i) in=1 ;;
		e) espec="$OPTARG" ;;
		o) ospec="$OPTARG" ;;
		O)
			ospec="$OPTARG"
			espec="$OPTARG"
		;;
		u) unbuffer=2  ;;
		U) unbuffer=0 ;;
		h)
			help
			exit 0
		;;
		H)
			help 1
			exit 0
		;;
		*) 
			help
			exit 1
		;;
	esac
done
shift "$(( OPTIND - 1 ))"
if ! (( $# | in )); then
	echo >&2 "No command specified."
	help
	exit 1
fi

shopt -s nullglob
getf(){ # cmd postfix spec 
	local d f arg
	if [[ "$3" = */* ]]; then
		REPLY="$3"
		return
	elif [[ -n "$3" ]]; then
		# Test [spec].[fd] [prog].[spec].[fd] [spec]
		set -- "$3.$2" "$1.$3.$2" "$3"
	else
		set -- "$1.$2"
	fi
	IFS=':'
	for arg; do
		for d in "${confs[@]}"; do
			for f in "$d/acolor/$arg"*; do
				if [[ -x "$f" ]]; then
					REPLY="$f"
					return
				fi
			done
		done
	done
	return 1
}

getf "$1" 1 "$ospec"
stdout_cmd="$REPLY"
getf "$1" 2 "$espec"
stderr_cmd="$REPLY"

if (( in )); then
	exec 2> >("$stderr_cmd" >&2)
	exec "$stdout_cmd"
fi
# no colorizer found, just exec
(( ${#stdout_cmd} + ${#stderr_cmd} )) || exec "$@"

if ((unbuffer == 2)) || [[ -t 0 ]] && ((unbuffer)); then
	command -v unbuffer >/dev/null && set -- unbuffer "$@"
fi
# set COMMAND to the command being run (quoted)
export COMMAND="${*@Q}"
"$@" 2> >("$stderr_cmd" >&2) | "$stdout_cmd"
